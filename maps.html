<!DOCTYPE html>
<html>
<head>
    <title>Dynamic Heatmap with Points</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.heat@latest/dist/leaflet-heat.js"></script>
    
    <style>
        #map { height: 100vh; width: 100%; }
        body { padding: 0; margin: 0; }
        /* Style for the circle markers */
        .my-circle-marker {
            background-color: #0000FF; /* Blue fill */
            border: 2px solid #FFFFFF; /* White border */
            border-radius: 50%; /* Makes it a circle */
            opacity: 0.8; /* Slightly transparent */
            pointer-events: none; /* Allows clicks to pass through to map */
        }
    </style>
</head>
<body>

<div id="map"></div>

<script>
    // 4. Create a default location (just lat/lon)
    var defaultLocations = [
        [51.505, -0.09]
    ];

    // 5. Get the URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const locationsParam = urlParams.get('locations'); // e.g., "lat,lon|lat,lon"
    
    var locations = []; // This will be [[lat, lon], [lat, lon], ...]

    // 6. Parse the 'locations' parameter string
    if (locationsParam) {
        try {
            const locationsArray = locationsParam.split('|');
            
            locations = locationsArray.map(locString => {
                const parts = locString.split(',');
                
                const lat = parseFloat(parts[0]);
                const lon = parseFloat(parts[1]);

                if (isNaN(lat) || isNaN(lon)) return null;

                return [lat, lon];

            }).filter(loc => loc !== null);

            if (locations.length === 0) {
                locations = defaultLocations;
            }

        } catch (e) {
            console.error("Error parsing locations:", e);
            locations = defaultLocations;
        }
    } else {
        locations = defaultLocations;
    }

    // 7. Initialize the map
    var map = L.map('map').setView([locations[0][0], locations[0][1]], 10);

    // 8. Add the OpenStreetMap tile layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: 'Â© <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);

    // 9. Create an array of [lat, lon, intensity] for the heatmap
    // Using a higher intensity (e.g., 2.0) will also make the heatmap darker
    const heatPoints = locations.map(loc => [loc[0], loc[1], 2.0]); 

    // 10. Add the heatmap layer and zoom to fit the points
    if (heatPoints.length > 0) {
        
        L.heatLayer(heatPoints, {
            radius: 25,       
            blur: 10,         
            minOpacity: 0.5,  // Increased further for more darkness
            max: 1.0,         // Max intensity value. Values above this are clamped.
            gradient: {0.0: 'blue', 0.5: 'lime', 1.0: 'red'}, // Optional: custom colors
            maxZoom: 18
        }).addTo(map);

        // --- NEW: Add individual circle markers for each coordinate ---
        var markerGroup = L.featureGroup();
        for (var i = 0; i < locations.length; i++) {
            var lat = locations[i][0];
            var lon = locations[i][1];
            
            L.circleMarker([lat, lon], {
                radius: 6,         // Size of the circle
                fillColor: "#0000FF", // Blue fill
                color: "#FFFFFF",  // White border
                weight: 2,         // Border thickness
                opacity: 1,        // Fully opaque border
                fillOpacity: 0.7   // Slightly transparent fill
            })
            .bindPopup(`Lat: ${lat.toFixed(4)}, Lon: ${lon.toFixed(4)}`) // Optional popup
            .addTo(markerGroup);
        }
        markerGroup.addTo(map);
        // ----------------------------------------------------------------

        // 11. Automatically zoom the map to fit all points (now including circle markers)
        // We'll use the 'markerGroup' for the bounds since it contains all visual elements
        map.fitBounds(markerGroup.getBounds().pad(0.5)); 
    }

</script>

</body>
</html>
